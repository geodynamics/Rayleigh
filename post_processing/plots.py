##################################################################
# This file is largely based on a similar file created by Thomas Gastine,
# who developed the post-processing python pipeline for MagIC 
# software (https://magic-sph.github.io/).
# The content of this file is taken from magic/python/magic/surf.py
##################################################################



from rayleigh_diagnostics import *
from plotlib import equatContour, merContour, radialContour
import matplotlib.pyplot as plt
import os
import numpy as np


class Plots:
    """
    This class allows to display the content of shell slices, az averaged
    files, and equatorial slices generated by Rayleigh.
    
    How to use it:
    First we add rayleigh path to PYTHONPATH
    so that ipython can import ploting class directly

    For example:
    export PYTHONPATH=$PYTHONPATH:/home/rakesh/GIT/Rayleigh/

    Now launch ipython

    >>> from post_processing import *
    >>> # This will ONLY load the packages defined in __init__.py file
    >>> # Create 'Plots' class object
    >>> p = Plots()
    >>> # To plot quantity code 2 from file 00001000 in Shell_Slices folder
    >>> p.radial_slice(filename='00001000', quantity_code=2)
    >>> # Similarly
    >>> s.equator_slice(filename='00001000', quantity_code=2)
    >>> s.az_avg(filename='00001000', quantity_code=2)
    """


    def radial_slice(self, filename='00000000', quantity_code=1, tindex=0, rindex=0, label='Quantity', 
                    proj='hammer', vmax=None, vmin=None,  levels=65, 
                    cm='seismic', lon_shift=0, normed=True, cbar=True, tit=True, lines=False):

        """
        :param filename: the name of the filename you want to display
        :type field: str
        :param quantity_code: the quantity code you want to display 
                              (must be present in the filename)
        :type quantity_code: int
        :param proj: the type of projection. Default is Hammer, in case
                     you want to use 'ortho' or 'moll', then Basemap is
                     required.
        :param tindex: the time index at which you want to display the data
                       default is 0
        :type tindex: int
        :param rindex: the radial index at which you want to display the data
                       default is 0
        :type rindex: int
        :param label: the plot title label you want. Vel, Temp, B field are 
                      defined based on quantity codes; 
                      otherwise it is 'Quantity'
        :type label: str
        :param vmax: maximum value of the contour levels
        :type vmax: float
        :param vmin: minimum value of the contour levels
        :type vmin: float
        :param levels: the number of levels in the contour
        :type levels: int
        :param cm: name of the colormap ('jet', 'seismic', 'RdYlBu_r', etc.)
        :type cm: str
        :param lon_shift: translate map in azimuth (in degrees)
        :type lon_shift: int
        :param tit: display the title of the figure when set to True
        :type tit: bool
        :param cbar: display the colorbar when set to True
        :type cbar: bool
        :param lines: when set to True, over-plot solid lines to highlight
                      the limits between two adjacent contour levels
        :type lines: bool
        :param normed: when set to True, the colormap is centered around zero.
                       Default is True, except for entropy/temperature plots.
        :type normed: bool
        """


        # Get the data from Shell_Slices directory
        dir_path = os.getcwd()
        ss = Shell_Slices(path=dir_path+'/Shell_Slices/', filename=filename)

        data = ss.vals[:,:,rindex,ss.lut[quantity_code],tindex]
        #ss.print_info()

        print('Available radii:', ss.radius)
        print('Available quantities:', ss.qv)
        print('Available times:', ss.time)

        if quantity_code == 1:
         label = 'Vr'
        elif quantity_code == 2:
         label = 'Vt'
        elif quantity_code == 3:
         label = 'Vp'
        elif quantity_code == 501:
         label = 'Temp/entropy'
        elif quantity_code == 503:
         label = 'Temp/entropy fluc'
        elif quantity_code == 801:
         label = 'Br'
        elif quantity_code == 802:
         label = 'Bt'
        elif quantity_code == 803:
         label = 'Bp'
          

        #label = label + 'at radius' + '{:+f}'.format(ss.radius[rindex])
        title = label + ' at radius ' + '%.3f'%(ss.radius[rindex]) \
                      + ' at time '   + '%.3f'%(ss.time[tindex])
 
        fig = radialContour(data, title, proj, vmax, vmin, levels, cm, normed, cbar, tit, lines)



#--------------------------------------------------------------------------

    def equator_slice(self, filename='00000000', quantity_code=1, tindex=0, label='Quantity', 
                      vmax=None, vmin=None,  levels=65, cm='seismic', normed=True, cbar=True, 
                      tit=True, normRad=False):
            
            
        # Get the data from Equatorial_Slices directory
        dir_path = os.getcwd()
        es = Equatorial_Slices(path=dir_path+'/Equatorial_Slices/', filename=filename)
        
        data = np.zeros((es.nphi+1,es.nr),dtype='float64')
        data[0:es.nphi,:] =es.vals[:,:,es.lut[quantity_code],tindex]
        data[es.nphi,:] = data[0,:]  #replicate phi=0 values at phi=2pi
         
        #ss.print_info()

        print('Available quantities:', es.qv)
        print('Available times:', es.time)

        if quantity_code == 1:
         label = 'Vr'
        elif quantity_code == 2:
         label = 'Vt'
        elif quantity_code == 3:
         label = 'Vp'
        elif quantity_code == 501:
         label = 'Temp/entropy'
        elif quantity_code == 503:
         label = 'Temp/entropy fluc'
        elif quantity_code == 801:
         label = 'Br'
        elif quantity_code == 802:
         label = 'Bt'
        elif quantity_code == 803:
         label = 'Bp'


        title = label + ' at time ' + '%.6f'%(es.time[tindex])

        fig = equatContour(data, es.radius, title, levels, cm, normed, vmax, vmin, cbar, tit, normRad)


#-------------------------------------------------------------------------

    def az_avg(self, filename='00000000', quantity_code=1, tindex=0, pol=False, polLevels=32, 
               mer=False, merLevels=32, label='Quantity', vmax=None, vmin=None,  levels=65, 
               cm='seismic', normed=True, cbar=True, tit=True, normRad=False):


        # Get the data from AZ_Avgs directory
        dir_path = os.getcwd()
        az = AZ_Avgs(path=dir_path+'/AZ_Avgs/', filename=filename)
        
        data =az.vals[:,:,az.lut[quantity_code],tindex]
        
        print('Available quantities:', az.qv)
        print('Available times:', az.time)
        
        if quantity_code == 1:
         label = 'Vr'
        elif quantity_code == 2:
         label = 'Vt'
        elif quantity_code == 3:
         label = 'Vp'
        elif quantity_code == 501:
         label = 'Temp/entropy'
        elif quantity_code == 503:
         label = 'Temp/entropy fluc'
        elif quantity_code == 801:
         label = 'Br'
        elif quantity_code == 802:
         label = 'Bt'
        elif quantity_code == 803:
         label = 'Bp'
         

        title = label + ' at time ' + '%.6f'%(az.time[tindex])


        fig, xx, yy = merContour(data, az.radius, title, levels, cm, normed, vmax, vmin, cbar, tit)

        if pol==True:
            rr2D = np.zeros((az.ntheta, az.nr))
            th2D = np.zeros_like(rr2D)
            pol_data = np.zeros_like(rr2D)
            brm = az.vals[:,:,az.lut[801],tindex] # get Br for poloidal lines
            thetas = np.arccos(az.costheta)
            for i in range(az.ntheta):
                rr2D[i, :] = az.radius
                th2D[i, :] = thetas[i]+np.pi/2.
            s2D = rr2D * np.abs(np.cos(th2D))
            pol_data[0, :] = -0.5*s2D[0, :]*brm[0, :]*thetas[0]
            
            for i in range(1, az.ntheta):
                pol_data[i, :] = pol_data[i-1, :] \
                                 -(s2D[i, :]*brm[i, :]+s2D[i-1,:]*brm[i-1,:])* \
                                 (th2D[i,:]-th2D[i-1,:])
            dataerr = pol_data[-1, :]-0.5*(s2D[-1,:]*brm[-1,:])*\
                      (np.pi-thetas[-1])
            for i in range(az.ntheta):
               pol_data[i, :] = pol_data[i, :] - dataerr*thetas[i]/np.pi
            poloLines = 0.5*pol_data/np.cos(th2D)
            #plot poloidal lines
            ax = fig.get_axes()[0]
            ax.contour(xx, yy, poloLines, polLevels, colors=['k'], linewidths=[0.8, 0.8])
            
            
        if mer==True:
            rr2D = np.zeros((az.ntheta, az.nr))
            th2D = np.zeros_like(rr2D)
            mer_data = np.zeros_like(rr2D)
            ref = ReferenceState(path=dir_path, filename='/reference')
            if ref.density[0] == ref.density[-1]:
                rho=1.
            else:
                rho = ref.density
            vrm = az.vals[:,:,az.lut[1],tindex] * rho
            thetas = np.arccos(az.costheta)
            for i in range(az.ntheta):
                rr2D[i, :] = az.radius
                th2D[i, :] = thetas[i]+np.pi/2.
            s2D = rr2D * np.abs(np.cos(th2D))
            mer_data[0, :] = -0.5*s2D[0, :]*vrm[0, :]*thetas[0]
            
            for i in range(1, az.ntheta):
                mer_data[i, :] = mer_data[i-1, :] \
                                 -(s2D[i, :]*vrm[i, :]+s2D[i-1,:]*vrm[i-1,:])* \
                                  (th2D[i,:]-th2D[i-1,:])
            dataerr = mer_data[-1, :]-0.5*(s2D[-1,:]*vrm[-1,:]) * (np.pi-thetas[-1])
            for i in range(az.ntheta):
                mer_data[i, :] = mer_data[i, :] - dataerr*thetas[i]/np.pi
            meriLines = 0.5*data/np.cos(th2D)
            #plot Merional lines
            maxMeri = abs(meriLines).max()
            minMeri = -maxMeri
            lev = np.linspace(minMeri, maxMeri, merLevels)
            ax = fig.get_axes()[0]
            ax.contour(xx, yy, meriLines, lev, colors=['k'], linewidths=[0.8])
 


#------------------------------------------------------------------------


